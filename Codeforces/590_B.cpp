#include <iostream>
using namespace std;

int n, goodSet,temp,sizes = 0;
long arr[201];

//대화를 k번 보여줄 수 있다. 처음은 0
//n개의 메세지를 받으면 i번째 메세지는 ID에게 받는다는걸 알게 된다.

void insert(int ins) {
	for (int i = 0; i < goodSet; i++) {
		if (arr[i] == ins) //같은게 있다면 아웃.
			return;
	}
	int temp = arr[0],temp2;
	arr[0] = ins;
	for (int i = 1; i < goodSet; i++) {
		temp2 = arr[i];
		arr[i] = temp;
		temp = temp2;
	}
	if (sizes < goodSet)
		sizes++;
}

int main() {
	cin >> n >> goodSet;
	for (int i = 0; i < n; i++) {
		cin >> temp;
		insert(temp);
	}
	cout << sizes << "\n";
	for (int i = 0; i < sizes; i++) {
		cout << arr[i] << " ";
	}
}

/*쉬운 버전과 하드 버전 사이의 유일한 차이점은 n과 k에 대한 제약이다.

당신은 스마트폰을 통해 인기 있는 소셜 네트워크 중 하나를 통해 메시지를 보내고 있다. 
당신의 스마트폰은 당신의 친구들과의 최근 대화를 기껏해야 k번 보여줄 수 있다. 
처음에는 화면이 비어 있다(즉, 표시되는 대화 수가 0과 같다).

각각의 대화는 당신과 몇몇 친구들 사이에 있다. 네 친구들 중 어느 한 명이라도 대화가 있다. 
그래서 각각의 대화는 당신의 친구에 의해 독특하게 정의된다.

너(갑자기!)는 미래를 보는 능력이 있다. 당신은 낮에 당신이 n개의 메시지를 받을 때, 
i번째 메시지는 ID (1≤idi≤10^9)를 가진 친구로부터 수신된다는 것을 알고 있다.

만약 당신이 현재 스마트폰에 표시되는 대화에서 ID로부터 메시지를 받는다면,
 화면의 대화는 변하지 않고 그들의 순서를 바꾸지 않는다. 당신은 메시지를 읽고 새로운 메시지를 계속 기다린다.

그렇지 않은 경우(즉, 화면에 관용어가 있는 대화가 없는 경우):

첫째, 화면에 표시되는 대화 횟수가 k일 경우 마지막 대화(위치 k)가 화면에서 제거된다.

이제 화면에 나오는 대화 횟수는 k 이하가 보장되고 친구 id와의 대화 내용은 화면에 표시되지 않는다.

친구 id와의 대화는 화면의 첫 번째(가장 위) 위치에 나타나고 표시된 다른 모든 대화는 한 쪽으로 이동한다.

당신의 임무는 모든 n개의 메시지를 처리한 후에 대화 목록을 찾는 것이다.

입력
입력의 첫 번째 줄에는 메시지 수와 스마트폰에서 표시할 수 있는 대화 수인 
두 개의 정수 n과 k(1≤n,k≤200)가 포함되어 있다.

입력의 두 번째 줄은 n 정수의 ID1,id2,...,idn(1≤idi≤109)을 포함하고 있다. 
여기서 숙어는 i번째 메시지를 보내는 친구의 ID이다.

산출량
출력의 첫 번째 줄에서 하나의 정수 m— 모든 n개의 메시지를 받은 후 표시되는 대화 수.

두 번째 줄에서 인쇄 m 정수 ID1,ids2,...,idsm, 여기서 idsi는 모든 n개의 메시지를 받은 후
 i 위치에 표시되는 대화에 해당하는 친구의 ID와 같아야 한다.*/